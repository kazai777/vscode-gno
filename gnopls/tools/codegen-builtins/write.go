package main

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
	"go.lsp.dev/protocol"
)

const (
	protoPkg           = "go.lsp.dev/protocol"
	completionItemType = "CompletionItem"
)

type GenContext struct {
	PackageName string
	SourcePath  string
	OmitSymbols []string
	PickSymbols []string
}

// generateSourceFile constructs a Go source file with map that contains completion items.
func generateSourceFile(genCtx GenContext, src []protocol.CompletionItem) (*jen.File, error) {
	f := jen.NewFile(genCtx.PackageName)
	f.HeaderComment("This file was generated by codegen-builtins, DO NOT EDIT!")
	f.HeaderComment("See: /tools/codegen-builtins")
	f.HeaderComment("")
	f.HeaderComment("Source: " + genCtx.SourcePath)
	if len(genCtx.PickSymbols) > 0 {
		f.HeaderComment("Picked: " + strings.Join(genCtx.PickSymbols, ","))
	}
	if len(genCtx.OmitSymbols) > 0 {
		f.HeaderComment("Skipped: " + strings.Join(genCtx.OmitSymbols, ","))
	}

	// disables named import caused by jen.Qual().
	f.ImportName(protoPkg, "protocol")

	bucketStmt, err := buildBucketMapStatement(src)
	if err != nil {
		return nil, err
	}

	f.Comment("buckets contains list of completions for builtin Gno functions grouped by a first letter.")
	f.Var().Id("buckets").Op("=").Map(jen.Rune()).Index().Qual(protoPkg, completionItemType).Values(bucketStmt)
	return f, nil
}

func buildBucketMapStatement(src []protocol.CompletionItem) (jen.Dict, error) {
	grouped := make(map[rune][]jen.Code)
	for _, item := range src {
		key := []rune(item.Label)[0]
		stmt, err := completionItemToStatement(item)
		if err != nil {
			return nil, err
		}

		grouped[key] = append(grouped[key], stmt)
	}

	dict := jen.Dict{}
	for key, entries := range grouped {
		lit := jen.Lit(key)
		dict[lit] = jen.Index().Qual(protoPkg, completionItemType).Values(entries...)
	}

	return dict, nil
}

func markupContentToStatement(doc protocol.MarkupContent) *jen.Statement {
	return jen.Qual(protoPkg, "MarkupContent").Values(jen.Dict{
		jen.Id("Kind"):  jen.Qual(protoPkg, "Markdown"),
		jen.Id("Value"): jen.Lit(doc.Value),
	})
}

func completionItemToStatement(item protocol.CompletionItem) (jen.Code, error) {
	var docStmt *jen.Statement
	switch doc := item.Documentation.(type) {
	case protocol.MarkupContent:
		docStmt = markupContentToStatement(doc)
	case *protocol.MarkupContent:
		if doc != nil {
			docStmt = markupContentToStatement(*doc)
		}
	case string:
		docStmt = jen.Lit(doc)
	default:
		return nil, fmt.Errorf("unexpected documentation field type: %#v", doc)
	}

	var insertTextFormatStmt *jen.Statement
	switch v := item.InsertTextFormat; v {
	case protocol.InsertTextFormatPlainText,
		protocol.InsertTextFormatSnippet:
		constId := "InsertTextFormat" + v.String()
		insertTextFormatStmt = jen.Qual(protoPkg, constId)
	default:
		insertTextFormatStmt = jen.Lit(float64(v))
	}

	var itemKindStmt *jen.Statement
	switch item.Kind {
	case
		protocol.CompletionItemKindText,
		protocol.CompletionItemKindMethod,
		protocol.CompletionItemKindFunction,
		protocol.CompletionItemKindConstructor,
		protocol.CompletionItemKindField,
		protocol.CompletionItemKindVariable,
		protocol.CompletionItemKindClass,
		protocol.CompletionItemKindInterface,
		protocol.CompletionItemKindModule,
		protocol.CompletionItemKindProperty,
		protocol.CompletionItemKindUnit,
		protocol.CompletionItemKindValue,
		protocol.CompletionItemKindEnum,
		protocol.CompletionItemKindKeyword,
		protocol.CompletionItemKindSnippet,
		protocol.CompletionItemKindColor,
		protocol.CompletionItemKindFile,
		protocol.CompletionItemKindReference,
		protocol.CompletionItemKindFolder,
		protocol.CompletionItemKindEnumMember,
		protocol.CompletionItemKindConstant,
		protocol.CompletionItemKindStruct,
		protocol.CompletionItemKindEvent,
		protocol.CompletionItemKindOperator,
		protocol.CompletionItemKindTypeParameter:
		constId := "CompletionItemKind" + item.Kind.String()
		itemKindStmt = jen.Qual(protoPkg, constId)
	default:
		// Unknown value, write as is.
		itemKindStmt = jen.Lit(int(item.Kind))
	}

	dict := jen.Dict{
		jen.Id("Label"):            jen.Lit(item.Label),
		jen.Id("Kind"):             itemKindStmt,
		jen.Id("InsertTextFormat"): insertTextFormatStmt,
		jen.Id("InsertText"):       jen.Lit(item.InsertText),
		jen.Id("Documentation"):    docStmt,
	}

	if item.Detail != "" {
		dict[jen.Id("Detail")] = jen.Lit(item.Detail)
	}

	return jen.Qual(protoPkg, completionItemType).Values(dict), nil
}
